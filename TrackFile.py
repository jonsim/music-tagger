"""Imports:
    Levenshtein: calculating string similarity
    TrackData: data about each file
    ID3v1Parser: parsing ID3v1 tag data from the file
    ID3v2Parser: parsing ID3v2 tag data from the file
    FilePathParser: parsing path data from the file
"""
import Levenshtein
import TrackData
import ID3v1Parser
import ID3v2Parser
import FilePathParser

class TrackFile(object):
    """Represents all data extracted from a file about a track.

    Attributes:
        file_path: string file path, the only required and certain piece
        cleaned_filename: string file name which may have been processed to
            remove invalid characters
        finalised: boolean flag indicating whether the 'final' TrackData field
            has been generated
        fp: TrackData extracted from the file path
        v1: TrackData extracted from the ID3v1 tag
        v2: TrackData extracted from the ID3v2 tag
        final: TrackData generated by combining all other TrackData fields
    """
    file_path = ""
    cleaned_filename = ""
    finalised = False
    fp = None
    v1 = None
    v2 = None
    final = None

    def __init__(self, file_path, cleaned_filename=""):
        """ Creates the TrackFile object.

        Args:
            file_path: String path to the music file.
            cleaned_filename: File name removed of any unnecessary data.
                Optional argument. Opting not to provide it will cause the
                cleaned filename to be generated automatically. The downside of
                this is that when automatic cleaning of the filename occurs it
                is treated in isolation to all other files in the directory (as
                it does not have access to them) so it cannot perform common
                word removal or other similar, contextual techniques.

        Returns:
            The initialised TrackFile object.
        """
        if file_path == "":
            raise Exception("Cannot create a TrackFile with an empty file_path.")
        self.file_path = file_path
        if cleaned_filename:
            self.cleaned_filename = cleaned_filename
        else:
            self.cleaned_filename = TrackData.clean_string(file_path.split('/')[-1], True)


    def __str__(self):
        if self.finalised:
            string = str(self.final)
        else:
            string = "TrackFile uncompressed data:\n"
            string += "  fp) %s\n" % (self.fp)
            string += "  v1) %s\n" % (self.v1)
            string += "  v2) %s"   % (self.v2)
        return string


    def load_all_data(self):
        """ Loads TrackData for the file from all available sources.

        Returns:
            None
        """
        self.fp = FilePathParser.read_file_path_data(self.file_path, self.cleaned_filename)
        self.v1 = ID3v1Parser.read_id3v1_tag_data(self.file_path)
        self.v2 = ID3v2Parser.read_id3v2_tag_data(self.file_path)


    def finalise_data(self):
        """ Generates the finalised data from all currently loaded sources.

        This is done by a voting procedure between all loaded sources. These
        loaded sources may be from filename parsing, an ID3v1 tag, an ID3v2 tag.
        Does not delete any of the old data, however the finalised flag is set
        which will cause other functions to read only this final data from the
        object. Many functions which act on the TrackFile require this
        finalisation to have taken place.

        Returns:
            None
        """
        def finalise_str(fp_str=None, v1_str=None, v2_str=None):
            """ Produces a single piece of string data from those provided.

            Args:
                fp_str: Optional string representing data from file path parsing
                v1_str: Optional string representing data from an ID3v1 tag
                v2_str: Optional string representing data from an ID3v2 tag

            Returns:
                A string best guess at the data from that provided.
            """
            # We tend to favour fp while v1 and v2 have equal weighting. We
            # assume v1 could have been truncated to 30 characters (hence why,
            # when it is compared with other strings they have to be cut down
            # and it is never directly returned).
            fp_v1_distance = 0
            fp_v2_distance = 0
            v1_v2_distance = 0
            distance_threshold = 3
            if fp_str and v1_str:
                fp_v1_distance = Levenshtein.distance(fp_str[:30], v1_str)
            if fp_str and v2_str:
                fp_v2_distance = Levenshtein.distance(fp_str, v2_str)
            if v1_str and v2_str:
                v1_v2_distance = Levenshtein.distance(v1_str, v2_str[:30])

            # If fp is similar to one of them, return fp. Otherwise if v1 and v2
            # are similar, return v2. Otherwise just return fp (as good as
            # random chance - something should probably be printed).
            if (fp_str and v1_str and (fp_v1_distance < distance_threshold)) or \
               (fp_str and v2_str and (fp_v2_distance < distance_threshold)):
                return fp_str
            elif v1_str and v2_str and (v1_v2_distance < distance_threshold):
                return v2_str
            elif fp_str:
                return fp_str
            elif v2_str:
                return v2_str
            elif v1_str:
                return v1_str
            else:
                # All string data is essential - raise an exception if missing.
                raise Exception("finalise_str called with no readable arguments.")

        def finalise_int(fp_int=None, v1_int=None, v2_int=None):
            """ Produces a single piece of integer data from those provided.

            Args:
                fp_int: Optional int representing data from file path parsing
                v1_int: Optional int representing data from an ID3v1 tag
                v2_int: Optional int representing data from an ID3v2 tag

            Returns:
                An int best guess at the data from that provided.
            """
            if (fp_int and v1_int and (fp_int == v1_int)) or \
               (fp_int and v2_int and (fp_int == v2_int)):
                return fp_int
            elif v1_int and v2_int and (v1_int == v2_int):
                return v2_int
            elif fp_int:
                return fp_int
            elif v2_int:
                return v2_int
            elif v1_int:
                return v1_int
            else:
                # Integer data is non-essential.
                return 0

        final = TrackData.TrackData()
        final.title = finalise_str(self.fp.title, self.v1.title, self.v2.title)
        final.album = finalise_str(self.fp.album, self.v1.album, self.v2.album)
        final.artist = finalise_str(self.fp.artist, self.v1.artist, self.v2.artist)
        final.track = finalise_int(self.fp.track, self.v1.track, self.v2.track)
        final.year = finalise_int(self.fp.year, self.v1.year, self.v2.year)
        final.genre = finalise_int(None, self.v1.genre, self.v2.genre)
        self.final = final
        self.finalised = True

